

# 1.序列
除集合外 还有一种容器 Sequenec<T>

## 1.1 元素
val n = sequenecof("one","two")

## 1.2 Iterable
如果已经有一个iterable对象，可以调用asSequence()

val num = listof("one","two")
val numsequ = num.asSequnce();

## 1.3 函数????
```
首次1执行，返回的结果+2再次执行
val oddNumbers = generateSequence(1) { it + 2 } // `it` 是上⼀个元素
println(oddNumbers.take(5).toList())//执行5次

val oddNumbersLessThan10 = generateSequence(1) { if (it + 2 < 10) it + 2 else null }
println(oddNumbersLessThan10.count())
```
## 1.4 组块、
```kotlin
    val oddNumbers = sequence {
        yield(1)
        yieldAll(listOf(3, 5))
        yieldAll(generateSequence(7) { it + 2 })
    }
    println(oddNumbers.take(5).toList())
```
    每一个sequence 内部都是一个元素，虽然是函数

##  1.5 序列操作
可以独立处理每个元素 map()  filter()
take() drop()
如果序列操作返回延迟⽣成的另⼀个序列，则称为 中间序列

## 1.6 Iterable 与 Sequence 之间的区别。

Iterable特点：每个条件独立执行
```
val words = "The quick brown fox jumps over the lazy dog".split(" ")
val lengthsList = words.filter { println("filter: $it"); it.length > 3 }
.map { println("length: ${it.length}"); it.length }
.take(4)
println("Lengths of first 4 words longer than 3 chars:")
println(lengthsList)

```

Sequence 执行同时满足多种条件的逻辑

    val words = "The quick brown fox jumps over the lazy dog".split(" ")
// 将列表转换为序列
    val wordsSequence = words.asSequence()
    val lengthsSequence = wordsSequence.filter { println("filter: $it"); it.length > 3 }
        .map { println("length: ${it.length}"); it.length }
        .take(4)
    println("Lengths of first 4 words longer than 3 chars")
// 末端操作：以列表形式获取结果。
    println(lengthsSequence.toList())

    结果：

  ```
    Lengths of first 4 words longer than 3 chars
    filter: The
    filter: quick
    length: 5
    filter: brown
    length: 5
    filter: fox
    filter: jumps
    length: 5
    filter: over
    length: 4
    [5, 5, 5, 4]
  ```

# 2 集合转换

## 2.1 映射map  映射 转换从另⼀个集合的元素上的函数结果创建⼀个集合

val numbers = setOf(1, 2, 3)
println(numbers.map { it * 3 })

## 2.2合拢 zip  合拢 转换是根据两个集合中具有相同位置的元素构建配对，不是map形式
zip() 返回 Pair 对象的列表（ List ）

val colors = listOf("red", "brown", "grey")
val animals = listOf("fox", "bear", "wolf")
println(colors zip animals)

## 2.3 关联 associateWith  关联 转换允许从集合元素和与其关联的某些值构建 Map

val numbers = listOf("one", "two", "three", "four")
println(numbers.associateWith { it.length })

结果：
{one=3, two=3, three=5, four=4}

## 2.4 打平 flatten  去除多层集合内部的层级

val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))
println(numberSets.flatten())

## 2.5 字符串表示  joinToString()

val numbers = listOf("one", "two", "three", "four")
println(numbers)
println(numbers.joinToString())



# 3 协程
轻量级线程、
delay 挂起函数，不造成阻塞，会挂起协程，只能在协程里用
runBlocking 阻塞
join 等待执行完毕

runBlocking 与 coroutineScope 可能看起来很类似，因为它们都会等待其协程体以及所有⼦协程结束。主要
区别在于，runBlocking ⽅法会阻塞当前线程来等待，⽽ coroutineScope 只是挂起，会释放底层线程⽤于其他
⽤途。
